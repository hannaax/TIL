프로미스는, 전통적 콜백 패턴이 가진 단점을 보완하며 비동기 처리 시점을 명확히 표현할 수 있는 장점이 있음

## 45.1 비동기 처리를 위한 콜백 패턴의 단점
- **콜백 헬**
	- 비동기 함수를 호출하면 함수 내부의 비동기로 동작하는 코드가 완료되지 않았다 해도 기다리지 않고 즉시 종료된다. 즉, 비동기 함수 내부의 비동기로 동작하는 코드는 비동기 함수가 종료된 후에 완료된다. 따라서 비동기 함수 내부의 비동기로 동작하는 코드에서 처리 결과를 외부로 반환하거나 상위 스코프의 변수에 할당하면 기대한 대로 동작하지 않는다.
	- 비동기 함수는 비동기 처리 결과를 외부에 반환할 수 없고, 상위 스코프의 변수에 할당할 수도 없다.
	  따라서 비동기 함수의 처리 결과(서버의 응답 등)에 대한 후속 처리는 비동기 함수 내부에서 수행해야 한다.
	  이때 비동기 함수를 범용적으로 사용하기 위해 비동기 함수에 비동기 처리 결과에 대한 후속 처리를 수행하는 `콜백 함수`를 전달하는 것이 일반적이다. 필요에 따라 비동기 처리가 성공하면 호출될 콜백 함수와 비동기 처리가 실패하면 호출될 콜백 함수를 전달할 수 있다.
- **에러 처리의 한계**
	- try 코드 블록 내에서 호출한 setTimeout 함수는 1초 후에 콜백 함수가 실행되도록 타이머를 설정하고, 이후 콜백 함수는 에러를 발생시킨다. 하지만 이 에러는 catch 코드 블록에서 캐치되지 않는다.
	  setTimeout 함수의 콜백 함수가 실행될때 setTimeout 함수는 이미 콜 스택에서 제거된 상태다.
	  이는 setTimeout 함수의 콜백 함수를 호출한 것이 setTimeout 함수가 아니라는 것을 의미한다.
	  setTimeout 함수의 콜백 함수의 호출자가 setTimeout 함수라면 콜 스택의 현재 실행 중인 실행 컨텍스트가 콜백 함수의 실행 컨택스트일때 현재 실행 중인 실행 컨텍스트의 하위 실행 컨텍스트가 setTimeout 함수여야 한다.
	- 에러는 호출자 방향으로 전파된다.
	  따라서 setTimeout 함수의 콜백 함수가 발생시킨 에러는 catch 블록에서 캐치되지 않는다.

## 45.2 프로미스의 생성
- 프로미스의 상태는 resolve 또는 reject 함수를 호출하는 것으로 결정된다.
- 프로미스는 비동기 처리 상태와 처리 결과를 관리하는 객체다.

## 45.3 프로미스의 후속 처리 메서드
프로미스의 비동기 처리 상태가 변화하면 후속 처리 메서드에 인수로 전달한 콜백 함수가 선택적으로 호출된다.
- Promise.prototype.then
- Promise.prototype.catch
- Promise.prototype.final

## 45.4 프로미스의 에러 처리

## 45.5 프로미스 체이닝

## 45.6 프로미스의 정적 메서드
- Promise.resolve / Promise.
- Promise.all
- Promise.race
- Promise.allSettled

## 45.7 마이크로태스크 큐
마이크로태스크 큐는 태스크 큐보다 우선순위가 높다.

## 45.8 fetch
- fetch 함수는 HTTP 응답을 나타내는 Response 객체를 래핑한 Promise 객체를 반환한다.
- fetch 함수가 반환하는 프로미스는 기본적으로 404 Not Found나 500 Internal Server Error와 같은 HTTP 에러가 발생해도 에러를 reject하지 않고 불리언 타입의 ok 상태를 false로 설정한 Response 객체를 resolve한다. 오프라인 등의 네트워크 상태나 CORS 에러에 의해 요청이 완료되지 못한 경우에만 프로미스를 reject한다.


---


## QUIZ
- **promise 생성자 함수가 비동기 처리를 수행할때 인수로 전달 받는 함수를 설명하세요.**
  Promise 생성자 함수는 executor(실행 함수)를 전달받는다.
  executor의 인수 resolve와 reject는 js에서 자체 제공하는 콜백이다.
  executor에선 결과를 즉시 얻든 늦게 얻든 상관없이 상황에 따라 인수로 넘겨준 콜백 중 하나를 반드시 호출해야 한다.
  
- **Promise는 왜 쓰나요?**
  비동기 처리를 위한 콜백 패턴은 콜백 헬이나 에러 처리가 곤란한 문제가 있어서, 이를 극복하기 위해 ES6에서 프로미스가 도입됐다.
  
- **Promise의 생명주기에 대해 설명해주세요.**
  프로미스를 실행하면 결과는 둘 중 하나다. 성공을 의미하는 fulfill 과 실패를 의미하는 reject 가 있고, 결과를 받기까지의 중간 단계를 pending 이라고 칭한다.
  
- **setTimeout과 Promise.resolve 중 어느 것이 먼저 처리되나요? 그 이유는 무엇인가요?**
  Promise.resolve가 먼저 처리된다. 그 이유는 프로미스의 후속 처리 메서드의 콜백 함수는 태스크 큐가 아니라 마이크로 태스크 큐에 저장되기 때문이다.
  
- **Promise와 마이크로태스크 큐를 연관지어 설명해주세요**
  태스크 큐는 비동기 작업을 돕기 위해 만들어졌으며, 실행할 콜백함수가 대기하는 큐다.
  이벤트 루프가 콜 스택이 비어있을때 태스크 큐에서 콜백을 가져온다.
  이벤트 루프가 태스크 큐에서 콜백을 가져오기 전에 마이크로 태스크 큐를 먼저 고려한다.
  프로미스(프로미스 콜백과 then,catch,finally의 콜백함수들)가 마이크로 태스크 큐에 담긴다.
  마이크로 태스크 큐에 담긴 프로미스 콜백이 태스크 큐에 대기중인 콜백보다 우선적으로 처리된다.